= PySignalDuino - FHEM Integrationsoptionen

Dieses Dokument skizziert 3 Optionen zur Integration der über MQTT publizierten JSON-Nachrichten von PySignalDuino in ein FHEM-System, das traditionell String-basierte Nachrichten via `Dispatch()` erwartet.

Das Quell-Topic ist: `signalduino/v1/state/messages` (oder ähnlich, basierend auf der Konfiguration des Basis-Topics in PySignalDuino), mit einem JSON-Payload, der `protocol_id`, `preamble` (Protokoll-Präambel, z.B. `W126#`) und `payload` (Daten-Payload) enthält.

== Lösungsoptionen

=== Option 1: MQTT2_DEVICE + Perl-Mapping (`json2nameValue` in `attr`)

Diese Option nutzt die Standardfunktionalität des FHEM-Moduls `MQTT2_DEVICE` in Verbindung mit einer Perl-Hilfsfunktion, um das JSON-Payload zu parsen und über den zentralen `Dispatch`-Mechanismus an die logischen Module weiterzuleiten.

**Implementierungs-Detail (POC):**
Es wurde eine Hilfsfunktion `MqttSignalduino_DispatchFromJSON($$)` in `99_MyUtils.pm` erstellt.

*   **Funktion:** Nimmt den JSON-String (vom MQTT-Event) und den Gerätenamen entgegen.
*   **Logik:** Dekodiert JSON, kombiniert `preamble` (z.B. `W126#`) und `payload` (z.B. `4001...`) und ruft `Dispatch()` mit dem Geräte-Hash auf.
*   **FHEM-Integration:** Aufruf erfolgt z.B. über `userReadings` oder `notify`.

[source,perl]
----
# Beispielaufruf in FHEM (z.B. userReadings oder notify)
{ MqttSignalduino_DispatchFromJSON($EVENT, $NAME) }
----

[cols="1,3"]
|===
|Kriterium | Beschreibung
|**Vorteile** | Keine volle Modul-Entwicklung nötig. Nutzt FHEM-Bordmittel (`99_MyUtils.pm`). Ermöglicht die Wiederverwendung von `Dispatch()` und bestehenden logischen Modulen.
|**Nachteile** | Erfordert manuelle Installation der Funktion in `99_MyUtils.pm`. Das `MQTT2_DEVICE` muss korrekt konfiguriert sein (z.B. `Clients` Attribut).
|**Implementierungsaufwand (grob)** | **Niedrig**. Erstellung der Perl-Funktion und einmalige Einrichtung.
|**Notwendige Änderungen** | **FHEM:** Ein `MQTT2_DEVICE` muss konfiguriert werden. Die Funktion `MqttSignalduino_DispatchFromJSON` muss in `99_MyUtils.pm` verfügbar sein.
|===


=== Option 1b: MQTT2_DEVICE + Perl-Bibliothek (Utils-Funktion)

Diese Option nutzt `MQTT2_DEVICE` zum Empfang des JSONs und lagert die Parsing- und Dispatch-Logik in eine Utility-Bibliothek (eine `.pm`-Datei, die Funktionen exportiert) aus. Die Funktion dieser Bibliothek wird direkt über die `readingList` des `MQTT2_DEVICE` aufgerufen.

[cols="1,3"]
|===
|Kriterium | Beschreibung
|**Vorteile** | Sauberer Code, aber manuelle Integration nötig. Das `MQTT2_DEVICE` wird minimalistisch gehalten. Erlaubt die Wiederverwendung von `Dispatch()`.
|**Nachteile** | Erfordert Installation einer `.pm`-Datei (ähnlich wie Option 2, aber kein volles Modul). Erfordert einen `notify` oder einen `userReadings`-Aufruf, um die Logik auszuführen.
|**Implementierungsaufwand (grob)** | **Niedrig bis Mittel**. Erstellung einer `.pm`-Utility-Datei mit einer Pars- und Dispatch-Funktion. Konfiguration eines `MQTT2_DEVICE`.
|**Notwendige Änderungen** | **FHEM:** Erstellung einer `.pm`-Datei mit einer Utility-Funktion (z.B. `SDU_DispatchJSON($$)`). Diese Funktion wird direkt in der `readingList` des `MQTT2_DEVICE` aufgerufen. Wichtig: Das Attribut `Clients` muss am `MQTT2_DEVICE` manuell gepflegt werden. **PySignalDuino:** Die Payload-Generierung liefert `preamble` und `payload` separat im JSON.
|===

=== Option 2: Eigenes FHEM-Modul (PySignalDuino-Bridge)

Ein neues FHEM-Modul, das die MQTT-Nachrichten von PySignalDuino abonniert und intern die `Dispatch()`-Funktion von FHEM mit den traditionellen Signalduino-Strings aufruft.

[cols="1,3"]
|===
|Kriterium | Beschreibung
|**Vorteile** | **Beste Kompatibilität**. Ermöglicht die Wiederverwendung aller bestehenden FHEM-Module (z.B. link:../../../.devcontainer/fhem-data/FHEM/14_SD_WS.pm[`14_SD_WS.pm`]), da die Bridge das ursprüngliche `Dispatch()`-Verhalten emuliert. Trennung von PySignalDuino-Logik (JSON) und FHEM-Logik (String-Dispatch).
|**Nachteile** | Erfordert die Entwicklung, Wartung und Installation eines neuen Perl-Moduls in FHEM.
|**Implementierungsaufwand (grob)** | **Mittel**. Entwicklung des Bridge-Moduls in Perl, das die MQTT-Subscription und die JSON-Parsing/Dispatch-Logik implementiert.
|**Notwendige Änderungen** | **FHEM:** Neues Perl-Modul (z.B. `98_PySignalDuinoBridge.pm` oder `00_PySignalDuinoBridge.pm`) muss erstellt werden, das den JSON-Payload empfängt, `preamble` und `payload` verknüpft.
|===

=== Option 3: Anpassung in PySignalDuino (FHEM-Mode)

PySignalDuino wurde bereits angepasst, um die Felder `preamble` und `payload` zu senden, die zusammen dem FHEM-Dispatch-Format entsprechen.

[cols="1,3"]
|===
|Kriterium | Beschreibung
|**Vorteile** | Flexibles Format (JSON), das sowohl FHEM als auch andere Systeme unterstützt.
|**Nachteile** | **Teilweise realisiert.** PySignalDuino sendet jetzt standardmäßig das Format mit `preamble` und `payload` im JSON.
|**Implementierungsaufwand (grob)** | **Erledigt**. Änderung in `signalduino/mqtt.py` ist bereits erfolgt.
|**Notwendige Änderungen** | **PySignalDuino:** `signalduino/mqtt.py` sendet `preamble` (z.B. `W126#`) und `payload` (Daten) separat. **FHEM:** Kombination von `preamble` und `payload` vor dem Dispatch.
|===

=== Option 4: Portierung der Dekodier-Logik (Client-Module) nach PySignalDuino

Anstatt nur Rohdaten zu senden, übernimmt PySignalDuino auch die Interpretation der Daten (z.B. Umrechnung von Hex-Werten in Temperatur, Luftfeuchtigkeit, Batteriestatus, Windgeschwindigkeit etc.). Das entspricht der Logik, die aktuell in FHEM-Modulen wie `14_SD_WS.pm` liegt.

[cols="1,3"]
|===
|Kriterium | Beschreibung
|**Vorteile** | **Perfekt für alle Konsumenten** (Home Assistant, Node-RED, FHEM, ioBroker), da keine proprietäre Dekodier-Logik im Zielsystem nötig ist. Die MQTT-Nachricht enthält direkt verwendbare Schlüssel-Wert-Paare (z.B. `{"temperature": 21.5, "humidity": 60, "battery": "ok"}`). Ermöglicht echtes "MQTT Auto Discovery" (z.B. für Home Assistant). Entkoppelt die Empfangslogik komplett von FHEM.
|**Nachteile** | **Extremer Aufwand.** Es müssen Dutzende/Hunderte von Protokoll-Dekodern von Perl nach Python portiert werden. Verschiebt die Komplexität massiv in dieses Projekt.
|**Implementierungsaufwand (grob)** | **Sehr Hoch**. Systematische Portierung der Logik aus diversen FHEM-Modulen nach Python.
|**Notwendige Änderungen** | **PySignalDuino:** Entwicklung einer Decoder-Schicht, die basierend auf Protokoll-ID den Hex-Payload interpretiert. Erweiterung des JSON-Payloads um dekodierte Felder. **FHEM:** `MQTT2_DEVICE` kann die JSON-Werte direkt als Readings übernehmen (kein Dispatch mehr nötig für diese Protokolle).
|===


== Betrachtung anderer Automatisierungslösungen (Home Assistant, Node-RED)

PySignalDuino publiziert die demodulierten Nachrichten in einem standardisierten JSON-Format über MQTT, was die Integration in andere Smart-Home-Systeme als FHEM erheblich vereinfacht.

[cols="1,1,1,2"]
|===
|Option | PySignalDuino-Payload | FHEM-spezifische Konsequenzen | Systemübergreifende Eignung (HA/Node-RED)
|**1, 1b, 2** | Standardisiertes JSON | Konvertierung/Parsing in FHEM notwendig. | **Gut.** Diese Systeme können JSON nativ und effizient parsen, benötigen aber eigene Logik (Templates/Scripts) zur Interpretation der Rohdaten, wenn FHEM dies nicht übernimmt.
|**3** | FHEM-spezifischer String (z.B. P49#...) | Direkte Integration in FHEM möglich. | **Schlecht.** HA/Node-RED müssten proprietäre FHEM-Strings parsen oder PySignalDuino müsste doppelt senden (JSON + String), was Bandbreite/Performance kostet.
|**4** | Dekodiertes JSON (Werte) | Keine Dispatch-Logik nötig; direkte Nutzung der Readings. | **Exzellent.** Der "Gold Standard". MQTT-Nachrichten sind selbsterklärend und sofort nutzbar. Ermöglicht Plug & Play.
|===

**Fazit:** 
*   Varianten, die das standardisierte JSON von PySignalDuino beibehalten (Option 1, 1b, 2), sind für eine Koexistenz gut geeignet.
*   **Option 4** ist der klare Gewinner für moderne IoT-Landschaften (HA, Node-RED), erfordert aber den größten Aufwand in PySignalDuino.


== Grobe POC-Implementierungen

Um die verschiedenen Optionen besser visualisieren zu können, folgen hier Code-Snippets und Diagramme.

=== Option 1: MQTT2_DEVICE + Perl-Mapping (`json2nameValue` in `attr`)

**FHEM-Konfiguration (MQTT2_DEVICE `readingList`):**
*(Hinweis: Das Attribut `Clients` muss am MQTT2_DEVICE manuell gesetzt werden, z.B. `:SD_WS:SD_...`)*
[source,perl]
----
signalduino/v1/state/messages:.* { json2nameValue($EVENT, 'sd_') }
sd_payload:.* { my $pre = ReadingsVal($NAME, "sd_preamble", ""); my $pay = ReadingsVal($NAME, "sd_payload", ""); Dispatch('signalduino', $pre . $pay) }
----

**Flussdiagramm:**
[mermaid]
....
sequenceDiagram
    participant P as PySignalDuino
    participant M as MQTT Broker
    participant F as FHEM (MQTT2_DEVICE)
    participant D as FHEM (Sensor Device)

    P ->> M: Publish JSON Payload (mit "preamble": "W126#", "payload": "40...")
    M ->> F: MQTT Message
    F ->> F: readingList: json2nameValue() -> Readings
    F ->> F: userReadings (optional): Trigger Dispatch()
    F ->> F: Combine preamble + payload
    F ->> F: Dispatch("W126#40...")
    F ->> D: Message an Dispatch()
    D ->> D: Handle Message
....

=== Option 1b: MQTT2_DEVICE + Perl-Bibliothek (Utils-Funktion)

**FHEM-Utility-Datei (z.B. in `FHEM/MyUtils.pm` oder separater `.pm`-Datei):**
[source,perl]
----
# In Utility-Datei
sub SDU_DispatchJSON($$) {
    my ($hash, $json_payload) = @_;
    use JSON;
    my $data_hash = JSON::decode_json($json_payload);
    my $msg = $data_hash->{preamble} . $data_hash->{payload};

    # Dispatch
    Dispatch($hash, $msg);
    return 1;
}
----

**FHEM-Konfiguration (MQTT2_DEVICE `readingList`):**
*(Hinweis: Das Attribut `Clients` muss am MQTT2_DEVICE manuell gesetzt werden, z.B. `:SD_WS:SD_...`)*
[source,perl]
----
signalduino/v1/state/messages:.* { SDU_DispatchJSON($hash, $EVENT) }
----

**Flussdiagramm:**
[mermaid]
....
sequenceDiagram
    participant P as PySignalDuino
    participant M as MQTT Broker
    participant F as FHEM (MQTT2_DEVICE)
    participant U as FHEM Utility (.pm)
    participant D as FHEM (Sensor Device)

    P ->> M: Publish JSON Payload
    M ->> F: MQTT Message
    F ->> U: readingList: SDU_DispatchJSON($hash, $EVENT)
    U ->> U: Parse JSON (combine "preamble" + "payload")
    U ->> F: Dispatch()
    F ->> D: Message an Dispatch()
    D ->> D: Handle Message
....

=== Option 2: Eigenes FHEM-Modul (PySignalDuino-Bridge)

**FHEM-Modul (Auszug aus `Bridge.pm`):**
[source,perl]
----
sub Bridge_Parse($) {
    my ($hash) = @_;
    # ... MQTT-Message-Queue abrufen ...
    # ... JSON-Payload abrufen ...
    use JSON;
    my $data_hash = JSON::decode_json($json_payload);
    my $msg = $data_hash->{preamble} . $data_hash->{payload};
    
    # Aufruf des Standard-Dispatch
    return Dispatch($hash, $msg);
}
----

**Flussdiagramm (Kapselung):**
[mermaid]
....
sequenceDiagram
    participant P as PySignalDuino
    participant M as MQTT Broker
    participant B as FHEM (Bridge Module)
    participant D as FHEM (Sensor Device)

    P ->> M: Publish JSON Payload
    M ->> B: MQTT Message (Subscription)
    B ->> B: Internal Parse (combine "preamble" + "payload")
    B ->> D: Dispatch("W126#40...")
    D ->> D: Handle Message
....

=== Option 3: Anpassung in PySignalDuino (FHEM-Mode)

**PySignalDuino-Code (in link:../../../signalduino/mqtt.py[`signalduino/mqtt.py`]):**
[source,python]
----
# Implementiert: Preamble und Payload separat
# if self._protocol_handler:
#    preamble = self._protocol_handler.check_property(message.protocol_id, 'preamble', '')
#    message_dict["preamble"] = preamble
#    message_dict["payload"] = message.payload.upper()
----

**FHEM-Konfiguration (MQTT2_DEVICE `readingList`):**
[source,perl]
----
signalduino/v1/state/messages:.* { my $h=JSON::decode_json($EVENT); Dispatch('signalduino', $h->{preamble} . $h->{payload}) }
----

**Flussdiagramm:**
[mermaid]
....
sequenceDiagram
    participant P as PySignalDuino
    participant M as MQTT Broker
    participant F as FHEM (MQTT2_DEVICE)
    participant D as FHEM (Sensor Device)

    P ->> P: Separate Preamble and Payload
    P ->> M: Publish JSON Payload
    M ->> F: MQTT Message
    F ->> D: readingList: Dispatch('signalduino', preamble + payload)
    D ->> D: Handle Message
....

=== Option 4: Portierung der Dekodier-Logik (Client-Module) nach PySignalDuino

**PySignalDuino-Code (Erweiterung der Protokoll-Handler):**
[source,python]
----
# Beispiel: Dekodierung eines Temperatursensors
def decode_protocol_49(hex_data):
    # Portierte Logik aus 14_SD_WS.pm
    temp_raw = int(hex_data[2:4], 16)
    temp = (temp_raw - 50) / 10.0
    return {
        "temperature": temp,
        "battery": "ok" if hex_data[0] == 'A' else "low"
    }

# Im MQTT-Publisher:
decoded_values = decode_protocol_49(data)
payload = {
    "protocol_id": "49",
    "preamble": "P49#",
    "payload": data,
    "values": decoded_values  # Neues Feld mit interpretierten Werten
}
mqtt_client.publish(topic, json.dumps(payload))
----

**FHEM-Konfiguration (MQTT2_DEVICE):**
[source,perl]
----
# Automatische Erstellung von Readings aus dem JSON
signalduino/v1/state/messages:.* { json2nameValue($EVENT) }
----
Dies erzeugt Readings wie `values_temperature` und `values_battery` direkt am Device.

**Flussdiagramm:**
[mermaid]
----
sequenceDiagram
    participant P as PySignalDuino
    participant M as MQTT Broker
    participant F as FHEM (MQTT2_DEVICE)
    participant H as Home Assistant

    P ->> P: Demodulate Signal
    P ->> P: Decode Values (Temp, Hum, etc.)
    P ->> M: Publish JSON with "values"
    par To FHEM
        M ->> F: MQTT Message
        F ->> F: Create Readings (Temp, Hum)
    and To Home Assistant
        M ->> H: MQTT Message
        H ->> H: Auto Discovery / Sensor Update
    end
----

== Detaillierte Bewertung

[cols="1,1,1,1,1"]
|===
|Feature | Option 1 (Mapping) | Option 1b (Utils) | Option 2 (Bridge-Modul) | Option 4 (Portierung)
|**Architektur** | "Bastel"-Lösung, unübersichtlich in Attributen | Sauberer Code, aber manuelle Integration nötig | Volle, standardkonforme FHEM-Integration | "Gold Standard", komplette Entkopplung
|**Dispatch-Fähigkeit** | **Kritisch:** Erfordert manuelles `Clients`-Attribut (fehleranfällig) | **Kritisch:** Erfordert manuelles `Clients`-Attribut | **Automatisch:** Integriert im Modul | Nicht nötig (Werte kommen direkt)
|**Konfigurationsaufwand** | Hoch (komplexe Regex im Attribut) | Mittel (Datei + Attribut) | Niedrig (ein `define`) | Sehr Niedrig (Auto-Create Readings)
|**Wartbarkeit** | Schlecht | Gut (Code ist versionierbar) | Sehr gut (gekapseltes Modul) | Sehr gut (zentral in Python)
|**Systemübergreifend** | Neutral (JSON bleibt erhalten) | Neutral (JSON bleibt erhalten) | Neutral (JSON bleibt erhalten) | **Exzellent** (Universal nutzbar)
|**Entwicklungsaufwand** | Niedrig | Mittel | Mittel | **Sehr Hoch**
|===

== Empfehlung

**Kurzfristig / Mittelfristig:**
**Option 2: Eigenes FHEM-Modul (PySignalDuino-Bridge)** oder **Option 1b (Utils-Funktion)**.

*   Diese Optionen ermöglichen die sofortige Weiternutzung der existierenden, mächtigen FHEM-Module ohne riesigen Portierungsaufwand.
*   Option 2 ist robuster für Endanwender ("Plug & Play"). Option 1b ist schneller für Entwickler umzusetzen.

**Langfristig / Vision:**
**Option 4: Portierung der Dekodier-Logik nach PySignalDuino**.

*   Dies sollte das strategische Ziel sein, um PySignalDuino zu einem echten, universellen IoT-Gateway zu machen.
*   Es wird empfohlen, dies **schrittweise** für die populärsten Protokolle (z.B. IT, WS) umzusetzen, während die anderen Protokolle weiterhin über Option 2 (Bridge) an FHEM übergeben werden.
*   Dies ermöglicht einen sanften Übergang: PySignalDuino liefert `payload` (für die Bridge) UND `values` (wenn der Decoder schon portiert ist).

=== Implementierungs-ToDos für Option 2 (Bridge-Modul)

.  **Erstellung des Bridge-Moduls:** Erstellen des FHEM Perl-Moduls (z.B. `98_PySignalDuinoBridge.pm` oder `00_PySignalDuinoBridge.pm`).
.  **MQTT-Abonnement:** Implementierung der Logik zur Subscription des Topics `signalduino/v1/state/messages` (oder konfiguriertem Topic).
.  **JSON-Parsing:** Implementierung der Perl-Logik zum Parsen des JSON-Payloads (z.g. mit `JSON::decode_json`).
.  **Dispatching:** Extraktion von `payload` aus dem JSON und Aufruf von `Dispatch(<msg>)`, um die Nachricht an das FHEM-System weiterzugeben.
.  **Konfiguration und Tests:** Dokumentation und Test der FHEM-Konfiguration (Definieren der Bridge).

== Geplanter Arbeitsablauf

.  **Phase 1 (Design/Planung):** Abschluss der Architekturanalyse und Erstellung des Plans (Abgeschlossen mit diesem Dokument).
.  **Phase 2 (Implementierung):**
    *   Erstellung des FHEM-Bridge-Moduls.
    *   Einrichtung der FHEM-Konfiguration für das Modul.
.  **Phase 3 (Validierung):** Testen der End-to-End-Kette (PySignalDuino publiziert JSON -> Bridge parst -> Bridge dismatched String -> FHEM Sensor-Device reagiert).

**Nächster Schritt:** Wechsel in den Code-Modus, um das FHEM-Bridge-Modul zu implementieren (oder mit der Implementierung zu beginnen).

= ADR 002: Verwendung des MqttCommandDispatcher für die MQTT-Befehlsbehandlung
:doctype: article :encoding: utf-8 :lang: de :status: Accepted :decided-at: 2026-01-04 :decided-by: Roo (Architekt)

[#adr-context]
== Kontext

Die MQTT-Befehlsbehandlung in `signalduino/mqtt.py` erfolgt derzeit über eine hartcodierte `if/elif`-Kette in der Methode `_handle_command` (Zeile 108). Diese Struktur ist schwer wartbar und skaliert schlecht, sobald neue Befehle hinzugefügt werden müssen, wie es für Factory Reset und das Abrufen von Hardware-Einstellungen erforderlich ist.

Der Code enthält bereits einen generischen, schema-validierenden Befehls-Dispatcher, den `MqttCommandDispatcher` (definiert in `signalduino/commands.py`). Dieser Dispatcher ist so konzipiert, dass er Befehlspfade gegen eine zentrale `COMMAND_MAP` prüft, Payloads validiert und die Ausführung an die entsprechenden Methoden im `SignalduinoController` delegiert.

Die zentrale Verwaltung der Befehle und deren Validierung ist eine bewährte Methode, um die Robustheit und Erweiterbarkeit der Schnittstelle zu gewährleisten.

[#adr-decision]
== Entscheidung

Die hartcodierte `if/elif`-Logik in `signalduino/mqtt.py` wird durch die Verwendung des `MqttCommandDispatcher` ersetzt.

. Der `MqttPublisher` in `signalduino/mqtt.py` wird eine Instanz des `MqttCommandDispatcher` erhalten.
. Die Methode `_handle_command` in `MqttPublisher` wird umgeschrieben, um den eingehenden Befehlspfad und Payload direkt an `MqttCommandDispatcher.dispatch()` zu übergeben.
. Die Fehler- und Erfolgsantworten werden vom `MqttCommandDispatcher` zurückgegeben und von `MqttPublisher` an die entsprechenden MQTT-Topics (`/responses` und `/errors`) publiziert.

[#adr-consequences]
== Konsequenzen

=== Positive Konsequenzen
* **Erweiterbarkeit:** Neue MQTT-Befehle (wie Factory Reset und Hardware Settings) können einfach durch Hinzufügen eines Eintrags zur `COMMAND_MAP` und der zugehörigen Controller-Methode hinzugefügt werden, ohne `signalduino/mqtt.py` zu ändern.
* **Trennung der Zuständigkeiten:** Die Verarbeitung der Befehlslogik (Validierung, Mapping, Ausführung) wird von der reinen MQTT-Transportlogik getrennt.
* **Validierung:** Alle eingehenden MQTT-Payloads werden automatisch gegen definierte JSON-Schemata validiert, was die Fehleranfälligkeit der Implementierung reduziert.
* **Konsistente Fehlerbehandlung:** Erfolgs- und Fehlerantworten werden an zentraler Stelle standardisiert.

=== Negative Konsequenzen
* **Refactoring-Aufwand:** Die bestehende Logik in `signalduino/mqtt.py` muss entfernt und durch den Dispatcher-Aufruf ersetzt werden.
* **Kopplung an Controller:** Der Dispatcher ist direkt an den `SignalduinoController` gekoppelt (was bereits der Fall war und akzeptiert wird).

[#adr-alternatives]
== Alternativen
* **Beibehaltung der if/elif-Kette:** Dies wurde abgelehnt, da es gegen die Prinzipien der Wartbarkeit und der Single Responsibility Principle (SRP) verstößt.
* **Anderer Dispatch-Mechanismus:** Die Verwendung des vorhandenen `MqttCommandDispatcher` ist die pragmatischste Lösung, da die Klasse bereits existiert und die Validierungsinfrastruktur bietet.